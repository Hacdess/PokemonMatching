FUNCTION setupMenuScene()
    // Load and set background image
    Load background image from "resources/img/background/background.png"
    Convert image to texture and assign it to background

    // Set up title text boxes
    FOR i FROM 0 TO 1 DO
        Set title content for title[i] to "POKEMON" if i is 0, else set it to "MATCHING"
        Set title font color to RED if i is 0, else set it to YELLOW
        Set title font size to a predefined value
        Set title border color to BlackTrans
        Calculate content length of title[i] based on its content and font size
        Calculate title position and border dimensions

    // Set up buttons
    FOR j FROM 0 TO 2 DO
        FOR i FROM 0 TO 1 DO
            Set button content for buttons[i][j] based on button position
            Set button font color to WHITE
            Set button font size to a predefined value
            Set button border color to DarkCyanTrans
            Calculate content length of buttons[i][j] based on its content and font size
            Calculate button position and border dimensions
            If i is 1, adjust button position and border for the second row

    // Initialize username variable
    Set username to NULL

    RETURN
END FUNCTION

PROCEDURE updateTitleColor()
    IF (GetTime() - markTime >= 1) THEN
        SWITCH (Title.FontColor)
            CASE RED:
                Set Title.FontColor to ORANGE
            CASE ORANGE:
                Set Title.FontColor to YELLOW
            CASE YELLOW:
                Set Title.FontColor to GREEN
            CASE GREEN:
                Set Title.FontColor to BLUE
            CASE BLUE:
                Set Title.FontColor to VIOLET
            CASE VIOLET:
                Set Title.FontColor to PINK
            CASE PINK:
                Set Title.FontColor to RED
        END SWITCH
        markTime = GetTime()
    END IF
END PROCEDURE

FUNCTION loadBackgroundImages(quantity)
    // Define variables
    path = ""
    textures = new Texture2D[quantity]

    // Load images
    FOR i = 0 TO quantity - 1
        path = "resources/img/background/background" + toString(i) + ".png"
        img = LoadImage(path)
        textures[i] = LoadTextureFromImage(img)
        UnloadImage(img)
    END FOR

    RETURN textures
END FUNCTION

FUNCTION loadPokemonImages(quantity)
    // Define variables
    path = ""
    textures = new Texture2D[quantity]

    // Load images
    FOR i = 0 TO quantity - 1
        path = "resources/img/pokemon/pokemon" + toString(i) + ".png"
        img = LoadImage(path)
        textures[i] = LoadTextureFromImage(img)
        UnloadImage(img)
    END FOR

    RETURN textures
END FUNCTION

FUNCTION loadHiddenImages(quantity)
    // Define variables
    path = ""
    textures = new Texture2D[quantity]

    // Load images
    FOR i = 0 TO quantity - 1
        path = "resources/img/hidden/hidden" + toString(i) + ".png"
        img = LoadImage(path)
        textures[i] = LoadTextureFromImage(img)
        UnloadImage(img)
    END FOR

    RETURN textures
END FUNCTION

//Account 

FUNCTION SignUpScene::setup
    Initialize set to 1
    Initialize account name and password counters and set their first characters to null

    Load an image from a file and convert it into a texture
    Release the loaded image from memory

    Initialize two title elements with text "POKEMON" and "MATCHING"
    Set the font colors of these titles to RED and YELLOW respectively

    Set initial coordinates and sizes for drawing:
        startY is set to one-fourth of the window height
        startX is set to one-fifth of the window width
        FontSize is set to one-eighth of the window height
        spacing is set to one-fifth of the FontSize

    FOR each title element from 0 to 1
        Set the FontSize and BorderColor
        Calculate the content length of the title
        Set the position of the title centered on the screen
        Set the border dimensions around the title
        Increment startY by the height of the title plus extra spacing
    END FOR

    Define text constants for "Username" and "Password"
    Set hints for input boxes to "Input username here" and "Input password here"
    Define button texts "Sign Up" and "Back"
    Set a warning message "Please input username and password"

    Adjust FontSize for smaller text elements
    Increment startY to position elements below the titles

    Define new dimensions for FontSize and spacing
    Calculate the dimensions and positions for username and password labels and input boxes
    FOR each label and input box from 0 to 1
        Set FontSize, BorderColor, and FontColor
        Calculate the content length
        Set the border dimensions and position
        For input boxes, adjust startX to align next to the labels
    END FOR

    Reset startX to initial value
    Increase startY to position the command text
    Set the command text properties and calculate its position

    Increase startY to position the confirm buttons
    Reset startX to a new position for button alignment
    FOR each confirm button from 0 to 1
        Set FontSize, BorderColor, and FontColor
        Calculate the content length
        Set the border dimensions and position
        Adjust startX for the next button
    END FOR
END FUNCTION

FUNCTION SignInScene::setup
    Initialize set to 1
    Initialize account name and password counters and set their first characters to null

    Load an image from a file and convert it into a texture
    Release the loaded image from memory

    Initialize two title elements with text "POKEMON" and "MATCHING"
    Set the font colors of these titles to RED and YELLOW respectively

    Set initial coordinates and sizes for drawing:
        startY is set to one-fourth of the window height
        startX is set to one-fifth of the window width
        FontSize is set to one-eighth of the window height
        spacing is set to one-fifth of the FontSize

    FOR each title element from 0 to 1
        Set the FontSize and BorderColor
        Calculate the content length of the title
        Set the position of the title centered on the screen
        Set the border dimensions around the title
        Increment startY by the height of the title plus extra spacing
    END FOR

    Define text constants for "Username" and "Password"
    Set hints for input boxes to "Input username here" and "Input password here"
    Define button texts "Sign In" and "Back"
    Set a warning message "Please input username and password"

    Adjust FontSize for smaller text elements
    Increment startY to position elements below the titles

    Define new dimensions for FontSize and spacing
    Calculate the dimensions and positions for username and password labels and input boxes
    FOR each label and input box from 0 to 1
        Set FontSize, BorderColor, and FontColor
        Calculate the content length
        Set the border dimensions and position
        For input boxes, adjust startX to align next to the labels
    END FOR

    Reset startX to initial value
    Increase startY to position the command text
    Set the command text properties and calculate its position

    Increase startY to position the confirm buttons
    Reset startX to a new position for button alignment
    FOR each confirm button from 0 to 1
        Set FontSize, BorderColor, and FontColor
        Calculate the content length
        Set the border dimensions and position
        Adjust startX for the next button
    END FOR
END FUNCTION

FUNCTION inputAccount(account)
    INITIALIZE key with the first character entered by the user

    WHILE key is greater than 0
        IF key is a printable character (between space and tilde on the ASCII table)
            APPEND character to account.name at the current position (account.nameCount)
            INCREMENT account.nameCount
            IF account.nameCount exceeds 20
                SET account.nameCount to 20 to prevent overflow
            SET the next position in account.name to null character to terminate the string
        END IF
        GET the next character entered by the user
    END WHILE

    IF the backspace key was pressed
        DECREMENT account.nameCount to remove the last character
        IF account.nameCount becomes negative
            RESET account.nameCount to 0
        SET the current position in account.name to null character to adjust the string
    END IF
END FUNCTION

FUNCTION inputPass(account)
    INITIALIZE key with the first character entered by the user

    WHILE key is greater than 0
        IF key is a printable character (between space and tilde on the ASCII table)
            APPEND character to account.pass at the current position (account.passCount)
            INCREMENT account.passCount
            IF account.passCount exceeds 20
                SET account.passCount to 20 to prevent overflow
            SET the next position in account.pass to null character to terminate the string
        END IF
        GET the next character entered by the user
    END WHILE

    IF the backspace key was pressed
        DECREMENT account.passCount to remove the last character
        IF account.passCount becomes negative
            RESET account.passCount to 0
        SET the current position in account.pass to null character to adjust the string
    END IF
END FUNCTION

FUNCTION storeAccount(account)
    CREATE or OPEN a file named "Account.txt" in append mode
    WRITE account.name, a separator '|', and account.pass to the file, followed by a newline
    CLOSE the file
END FUNCTION

FUNCTION isExistedUsername(account)
    OPEN file "Account.txt" in read mode

    DECLARE variables:
        s (character for delimiter),
        name (array of 20 characters),
        pass (array of 20 characters),
        t (string for storing file lines)

    READ the first line from the file and ignore it (not necessary for username check)

    WHILE not end of file
        READ a line from the file into t
        PARSE the line using a stringstream to extract name, delimiter, and password

        IF first character of name and password are not null
            IF name matches account.name
                CLOSE the file
                RETURN True (username exists)
            END IF
        END IF
    END WHILE

    CLOSE the file
    RETURN False (username does not exist)
END FUNCTION

FUNCTION isExistedUsername(account)
    OPEN file "Account.txt" in read mode

    DECLARE variables:
        s (character for delimiter),
        name (array of 20 characters),
        pass (array of 20 characters),
        t (string for storing file lines)

    READ the first line from the file and ignore it (not necessary for username check)

    WHILE not end of file
        READ a line from the file into t
        PARSE the line using a stringstream to extract name, delimiter, and password

        IF first character of name and password are not null
            IF name matches account.name
                CLOSE the file
                RETURN True (username exists)
            END IF
        END IF
    END WHILE

    CLOSE the file
    RETURN False (username does not exist)
END FUNCTION

FUNCTION checkCorrectPassword(account)
    OPEN file "Account.txt" in read mode

    DECLARE variables:
        s (character for delimiter),
        name (array of 20 characters),
        pass (array of 20 characters),
        t (string for storing file lines)

    READ the first line from the file and ignore it (considered unnecessary)

    WHILE not end of file
        READ a line from the file into t
        PARSE the line using a stringstream to extract name, delimiter, and password

        IF first character of name and password are not null
            IF name matches account.name AND password does not match account.pass
                CLOSE the file
                RETURN False (indicates password is incorrect for given username)
            END IF
        END IF
    END WHILE

    CLOSE the file
    RETURN True (indicates either no matching username found, or password is correct)
END FUNCTION


FUNCTION initMusicAndSound()
    CALL InitAudioDevice()
    GET themeMusic = CALL LoadMusicStream("resources/Sound/themeMusic.mp3")
    GET correctMatching = CALL LoadSound("resources/Sound/correctMatching.wav")
    GET wrongMatching = CALL LoadSound("resources/Sound/WrongMatching.wav")
    GET winning = CALL LoadSound("resources/Sound/winning.wav")
    GET losing = CALL LoadSound("resources/Sound/Losing.wav")
    GET pressButton = CALL LoadSound("resources/Sound/PressButton.wav")
    GET wrongSign = CALL LoadSound("resources/Sound/wrongSign.wav")
    GET moving =  CALL LoadSound("resources/Sound/Moving.wav")


FUNCTION MatchingType makeHint (Pokemon** pokemons, const short& row, const short& col, Selector2D& hint1, Selector2D& hint2, Node*& path)

    INITIALIZE res as MatchingType to NONE
    FOR hint1.y FROM 1 To row - 1
        FOR hint1.x FROM 1 TO col - 1
            FOR hint1.y FROM 1 TO row - 1 
                 FOR hint1.x FROM 1 to col - 1 
                    res IS EQUAL WITH Matching (I, L, U, Z) BY CALL checkMatching (pokemons, hint1, hint2, row, col, path) 
                    IF (res DIFFERENT FROM None) THEN
                        return res
                    END If
                END FOR
            END FOR
        END FOR
    END FOR
    return res


FUNCTION shuffle2D(Po2D, row, col)
    DECLARE i, j as integers
    SEED random number generator once with current time
    FOR i FROM 1 TO row - 2
        FOR j FROM 1 TO col - 2
            DECLARE randRow as short, ASSIGN it to random value between 1 and row - 2
            DECLARE randCol as short, ASSIGN it to random value between 1 and col - 2
            CALL swapPokemon with Po2D[i][j] and Po2D[randRow][randCol]
        END FOR
    END FOR
END FUNCTION


METHOD Pokemon::draw
    // Draw a rectangle at the specified location with specified background color
    DRAW Rectangle at Pokemon's border coordinates with background color

    // Draw the Pokemon image scaled to fit within the rectangle
    DRAW Image 'img' scaled and cropped appropriately
        FROM source rectangle {0, 0, image width, image height}
        TO destination rectangle {position x, position y, size, size}
        WITH rotation of 0 degrees and color mask 'cover'
END METHOD

METHOD Pokemon::unSeen
    SET shown to 0
END METHOD

FUNCTION readImageBackground(quantity)
    DECLARE path as string
    DECLARE resTexture as array of Texture2D with size equal to quantity

    FOR i FROM 0 TO quantity - 1
        SET path to "resources/img/background/background" + convert i to string + ".png"
        DECLARE img as Image, LOAD image from path
        SET resTexture[i] to texture converted from img
        UNLOAD img to free resources
    END FOR

    RETURN resTexture
END FUNCTION

FUNCTION readImagePokemon(quantity)
    DECLARE path as string
    DECLARE resTexture as array of Texture2D with size equal to quantity

    FOR i FROM 0 TO quantity - 1
        SET path to "resources/img/pokemon/pokemon" + convert i to string + ".png"
        DECLARE img as Image, LOAD image from path
        SET resTexture[i] to texture converted from img
        UNLOAD img to free resources
    END FOR

    RETURN resTexture
END FUNCTION

FUNCTION readImageHidden(quantity)
    DECLARE path as string
    DECLARE resTexture as array of Texture2D with size equal to quantity

    FOR i FROM 0 TO quantity - 1
        SET path to "resources/img/hidden/hidden" + convert i to string + ".png"
        DECLARE img as Image, LOAD image from path
        SET resTexture[i] to texture converted from img
        UNLOAD img to free resources
    END FOR

    RETURN resTexture
END FUNCTION

FUNCTION shuffle1D(Po1D, size)
    DECLARE i, j as integers
    SEED random number generator with current time

    FOR i FROM 0 TO size - 1
        SET j to a random integer from 0 to size - 1
        CALL swapPokemon with Po1D[i] and Po1D[j]
    END FOR
END FUNCTION

FUNCTION shuffle2D(Po2D, row, col)
    DECLARE i, j as integers

    FOR i FROM 1 TO row - 2
        FOR j FROM 1 TO col - 2
            SEED random number generator with current time each iteration (Note: This is inefficient and should ideally be seeded once outside the loop)
            SET randomRow to a random integer from 1 to row - 2
            SET randomCol to a random integer from 1 to col - 2
            CALL swapPokemon with Po2D[i][j] and Po2D[randomRow][randomCol]
        END FOR
    END FOR
END FUNCTION

METHOD GameBoard::checkMatchAble
    DECLARE i, j, x, y as integers
    DECLARE temp as pointer to Node, initialize to NULL

    FOR i FROM 1 TO row - 2
        FOR j FROM 1 TO col - 2
            FOR y FROM 1 TO row - 2
                FOR x FROM 1 TO col - 2
                    DECLARE checkMatch1 as Selector2D with x = j and y = i
                    DECLARE checkMatch2 as Selector2D with x = x and y = y
                    IF checkMatching(pokemons, checkMatch1, checkMatch2, row, col, temp) is not None
                        CALL removePath with temp
                        RETURN True (matchable)
                    END IF
                END FOR
            END FOR
        END FOR
    END FOR
    RETURN False (not matchable)
END METHOD

FUNCTION makeHint(pokemons, row, col, by reference hint1, by reference hint2, by reference path)
    DECLARE res as MatchingType, initialize to None

    FOR hint1.y FROM 1 TO row - 2
        FOR hint1.x FROM 1 TO col - 2
            FOR hint2.y FROM 1 TO row - 2
                FOR hint2.x FROM 1 TO col - 2
                    SET res to checkMatching(pokemons, hint1, hint2, row, col, path)
                    IF res is not None
                        RETURN res (a valid hint found)
                    END IF
                END FOR
            END FOR
        END FOR
    END FOR

    RETURN res (no valid hints, return None)
END FUNCTION

METHOD GameBoard::isEmpty
    FOR i FROM 1 TO row - 2
        FOR j FROM 1 TO col - 2
            IF pokemons[i][j].shown is True
                RETURN False (board is not empty)
            END IF
        END FOR
    END FOR
    RETURN True (board is empty)
END METHOD

FUNCTION GameBoard::createTable(quantity)
    SEED the random number generator with current time

    DECLARE randNum, i, j as integers
    DECLARE size as integer, CALCULATE as (row - 2) * (col - 2)
    DECLARE pos as integer, INITIALIZED to 0
    DECLARE sizePokemon as float, CALCULATE as window width divided by (1.75 times col)
    DECLARE padding as float, CALCULATE as sizePokemon divided by 30
    DECLARE startX, startY as float, INITIALIZED to 0

    DECLARE temp as array of Pokemon with size 'size'
    FOR i FROM 0 TO size - 1
        SET randNum to a random number modulo quantity
        // Ensure every two consecutive Pokemon are the same
        FOR TWO consecutive items in temp (index i and i+1)
            SET their ID to randNum
            SET their img to corresponding image from PokemonsImg using randNum
            SET their size to sizePokemon
            SET their cover to WHITE
            SET their back to PokeBack
            INCREMENT i
        END FOR
    END FOR

    // Shuffle the temporary array of Pokemon three times
    FOR i FROM 0 TO 2
        CALL shuffle1D with temp and size
    END FOR

    // Allocate memory for a 2D array of Pokemon
    INITIALIZE pokemons as a new array of pointers to Pokemon arrays
    FOR i FROM 0 TO row - 1
        INITIALIZE pokemons[i] as a new Pokemon array of size col

        FOR j FROM 0 TO col - 1
            IF i is 0 OR j is 0 OR i is row - 1 OR j is col - 1
                SET border and special characters for edge Pokemon
            ELSE
                // Set non-border Pokemon properties from shuffled list
                COPY properties from temp at position pos to pokemons[i][j]
                INCREMENT pos
                SET pokemons[i][j].shown to 1
            END IF

            // Set common properties for all Pokemon
            SET pokemons[i][j].size to sizePokemon
            SET pokemons[i][j].pos to (startX, startY)
            SET pokemons[i][j].border based on position and size

            // Adjust startX for the next Pokemon in the row or reset if at end of row
            IF j is not last in row
                INCREMENT startX by sizePokemon plus padding
            ELSE
                RESET startX to 0
            END IF
        END FOR

        // Adjust startY for the next row
        INCREMENT startY by sizePokemon plus padding
    END FOR

    // Initialize selection controls for the game
    SET selector to (1, 1)
    SET selected to (0, 0)
    SET player2 to (1, 1)
    SET selected2 to (0, 0)

    // Clean up temporary array to free memory
    DELETE array temp
END FUNCTION

METHOD GameBoard::draw(isDual)
    DECLARE i, j as integers

    FOR i FROM 0 TO row - 1
        FOR j FROM 0 TO col - 1
            // Highlight the current selection or dual player selection
            IF (selector position matches (i, j)) OR (isDual is true AND player2 position matches (i, j))
                SET pokemons[i][j].back to WHITE
                IF pokemons[i][j] is not shown
                    DRAW rectangle at pokemons[i][j].border with slightly transparent gray
                END IF
            END IF

            // Apply gray background if the Pokemon is selected
            ELSE IF pokemons[i][j].selected
                SET pokemons[i][j].back to slight gray
                SET pokemons[i][j].cover to slight gray
            ELSE
                // Reset background if not selected or highlighted
                SET pokemons[i][j].back to default PokeBack
                SET pokemons[i][j].cover to WHITE
            END IF

            // Draw the Pokemon if it is set to be shown
            IF pokemons[i][j].shown
                CALL pokemons[i][j].draw
            END IF
        END FOR
    END FOR
END METHOD

FUNCTION drawPath (Node* path, const Pokemon& pokemon) 
    IF BOTH path AND path -> next DIFFERENT FROM NULL THEN
        SET cur to path;
        SET next to path -> next;

        CALL DrawCircle (cur -> x, cur -> y, pokemon.size DIVIDE 8, GREEN)

        WHILE not end of list
        CALL  DrawLineEx ({next -> x, next -> y}, {cur -> x, cur -> y}, pokemon.size DIVIDE 8, GREEN)
        CALL DrawCircle (cur -> x, cur -> y, pokemon.size DIVIDE 16, GREEN)
        SET  cur to next
        SET next to next -> next
        END WHILE

        DrawCircle (cur -> x, cur -> y, pokemon.size / 8, GREEN)
    END IF
